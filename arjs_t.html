<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Horse - Markerless</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #arjs-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #status {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        #instructions {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 15px;
            font-size: 14px;
            text-align: center;
            max-width: 300px;
            z-index: 100;
            backdrop-filter: blur(10px);
            display: none;
        }

        a-scene {
            width: 100%;
            height: 100%;
        }

        /* Скрываем стандартные элементы AR.js */
        .a-enter-vr-button,
        .a-orientation-modal {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="arjs-container">
        <div id="status">Инициализация AR...</div>
        <div id="instructions">
            Наведите камеру на поверхность и коснитесь экрана для размещения модели лошади
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.0/build/three.min.js"></script>
    
    <!-- AR.js -->
    <script src="./ar-threex.js"></script>
    
    <!-- GLTFLoader для Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        const statusEl = document.getElementById('status');
        const instructionsEl = document.getElementById('instructions');
        const container = document.getElementById('arjs-container');

        let scene, camera, renderer;
        let arToolkitSource, arToolkitContext;
        let model = null;
        let modelPlaced = false;
        let markerRoot = null;
        let animationMixer = null;
        let clock = new THREE.Clock();
        let floorPlane = null; // Виртуальная плоскость пола
        let cameraAngle = 0; // Угол наклона камеры
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        let worldModelPosition = null; // Мировая позиция модели в локальных координатах камеры при размещении
        let initialCameraRotation = null; // Начальная ориентация камеры при размещении
        let deviceOrientation = { alpha: 0, beta: 90, gamma: 0 }; // Текущая ориентация устройства
        let initialDeviceOrientation = null; // Начальная ориентация устройства при размещении
        let lastDeviceMotion = { x: 0, y: 0, z: 0 }; // Последнее движение устройства

        // Инициализация
        function init() {
            // Создаем сцену
            scene = new THREE.Scene();

            // Создаем камеру
            camera = new THREE.PerspectiveCamera(
                70,
                window.innerWidth / window.innerHeight,
                0.01,
                1000
            );

            // Создаем рендерер
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // Инициализация AR.js
            initAR();

            // Загрузка модели
            loadModel();

            // Обработка изменения размера окна
            window.addEventListener('resize', onWindowResize);

            // Обработка клика для размещения модели (на canvas и на контейнере)
            renderer.domElement.addEventListener('click', onCanvasClick, false);
            renderer.domElement.style.pointerEvents = 'auto';
            renderer.domElement.style.position = 'relative';
            renderer.domElement.style.zIndex = '10';
            
            // Также добавляем обработчик на контейнер на случай если canvas не получает клики
            container.addEventListener('click', (e) => {
                // Проверяем что клик не по UI элементам
                if (e.target.id !== 'status' && e.target.id !== 'instructions' && 
                    e.target.parentElement.id !== 'status' && e.target.parentElement.id !== 'instructions') {
                    onCanvasClick(e);
                }
            }, false);
        }

        // Инициализация AR.js
        function initAR() {
            // AR.js источник (камера)
            arToolkitSource = new THREEx.ArToolkitSource({
                sourceType: 'webcam',
            });

            arToolkitSource.init(() => {
                arToolkitSource.onResizeElement();
                arToolkitSource.onResize();
                
                // Добавляем видео элемент
                const videoElement = arToolkitSource.domElement;
                videoElement.style.position = 'absolute';
                videoElement.style.top = '0';
                videoElement.style.left = '0';
                videoElement.style.width = '100%';
                videoElement.style.height = '100%';
                videoElement.style.objectFit = 'cover';
                videoElement.style.pointerEvents = 'none'; // Позволяет клики проходить через видео
                container.insertBefore(videoElement, container.firstChild);

                // AR.js контекст для markerless режима
                arToolkitContext = new THREEx.ArToolkitContext({
                    cameraParametersUrl: './camera_para.dat',
                    detectionMode: 'mono',
                    maxDetectionRate: 30,
                    canvasWidth: arToolkitSource.domElement.clientWidth,
                    canvasHeight: arToolkitSource.domElement.clientHeight,
                    imageSmoothingEnabled: true,
                });

                arToolkitContext.init(() => {
                    // Обновляем матрицу проекции камеры
                    camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
                    
                    // Добавляем освещение для видимости модели
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                    scene.add(ambientLight);
                    
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                    directionalLight.position.set(1, 1, 1);
                    scene.add(directionalLight);
                    
            // Создаем виртуальную плоскость пола для размещения модели
            floorPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            
            // Создаем корневой объект для модели
            markerRoot = new THREE.Group();
            scene.add(markerRoot);
            
            // Создаем визуальный индикатор плоскости (опционально, можно скрыть)
            // Это помогает понять, где будет размещена модель
            const planeHelper = new THREE.PlaneHelper(floorPlane, 2, 0xffff00);
            planeHelper.visible = false; // Скрываем по умолчанию
            scene.add(planeHelper);

                    statusEl.textContent = 'AR готов. Загрузка модели...';
                    
                    // Инициализируем систему трекинга движения
                    initMotionTracking();
                    
                    // Начинаем анимационный цикл
                    animate();
                    
                    // Инициализация трекинга движения выполняется в initMotionTracking()
                });
            });
        }

        // Загрузка 3D модели
        function loadModel() {
            const loader = new THREE.GLTFLoader();
            
            loader.load(
                './Horse_animation.gltf',
                (gltf) => {
                    model = gltf.scene;
                    
                    // Настройка модели
                    model.scale.set(0.1, 0.1, 0.1); // Увеличиваем масштаб для лучшей видимости
                    model.position.set(0, 0, 0);
                    model.visible = false;
                    
                    // Добавляем модель сразу в сцену для тестирования
                    // Будет перемещена к markerRoot при размещении
                    scene.add(model);
                    
                    // Настройка анимаций, если они есть
                    if (gltf.animations && gltf.animations.length > 0) {
                        animationMixer = new THREE.AnimationMixer(model);
                        gltf.animations.forEach((clip) => {
                            animationMixer.clipAction(clip).play();
                        });
                    }
                    
                    console.log('Модель загружена успешно', model);
                    statusEl.textContent = 'Модель загружена. Коснитесь экрана для размещения.';
                    instructionsEl.style.display = 'block';
                    
                    // Автоматическое размещение через 2 секунды, если пользователь не разместил вручную
                    setTimeout(() => {
                        if (!modelPlaced) {
                            placeModelAtCenter();
                        }
                    }, 2000);
                },
                (progress) => {
                    const percent = (progress.loaded / progress.total * 100).toFixed(0);
                    statusEl.textContent = `Загрузка модели: ${percent}%`;
                },
                (error) => {
                    console.error('Ошибка загрузки модели:', error);
                    statusEl.textContent = 'Ошибка загрузки модели: ' + error.message;
                }
            );
        }

        // Обработка ориентации устройства для определения угла камеры
        function onDeviceOrientation(event) {
            if (event.beta !== null) {
                // Сохраняем полную ориентацию устройства
                deviceOrientation.alpha = event.alpha || 0;
                deviceOrientation.beta = event.beta || 90;
                deviceOrientation.gamma = event.gamma || 0;
                
                // beta - угол наклона устройства вперед/назад (0-180)
                // Нормализуем угол наклона и ограничиваем диапазон
                let angle = (event.beta - 90) * Math.PI / 180;
                // Ограничиваем угол в разумных пределах (-45 до 45 градусов)
                angle = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, angle));
                cameraAngle = angle;
            }
        }
        
        // Инициализация системы трекинга движения устройства
        function initMotionTracking() {
            // Пытаемся использовать DeviceOrientation для более точного трекинга
            if (window.DeviceOrientationEvent) {
                // Запрашиваем разрешение на использование DeviceOrientation (для iOS 13+)
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                window.addEventListener('deviceorientation', onDeviceOrientation, false);
                                statusEl.textContent = 'Трекинг движения активирован';
                            } else {
                                // Если разрешение не получено, используем альтернативный метод
                                initDeviceMotion();
                            }
                        })
                        .catch((error) => {
                            console.error('Ошибка запроса разрешения DeviceOrientation:', error);
                            initDeviceMotion();
                        });
                } else {
                    // Для браузеров, которые не требуют разрешения
                    window.addEventListener('deviceorientation', onDeviceOrientation, false);
                }
            } else {
                // Если DeviceOrientation не поддерживается, пробуем DeviceMotion
                initDeviceMotion();
            }
        }
        
        // Альтернативный способ определения угла через акселерометр (если DeviceOrientation недоступен)
        function initDeviceMotion() {
            if (window.DeviceMotionEvent) {
                // Запрашиваем разрешение для iOS 13+
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    DeviceMotionEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                setupDeviceMotion();
                            } else {
                                statusEl.textContent = 'Трекинг движения недоступен. Модель может не закрепляться в пространстве.';
                            }
                        })
                        .catch((error) => {
                            console.error('Ошибка запроса разрешения DeviceMotion:', error);
                        });
                } else {
                    setupDeviceMotion();
                }
            } else {
                statusEl.textContent = 'Трекинг движения не поддерживается. Модель будет следовать за камерой.';
            }
        }
        
        function setupDeviceMotion() {
            window.addEventListener('devicemotion', (event) => {
                if (event.accelerationIncludingGravity) {
                    const accel = event.accelerationIncludingGravity;
                    
                    // Вычисляем угол наклона на основе гравитации
                    const angle = Math.atan2(accel.x, accel.z) - Math.PI / 2;
                    if (!isNaN(angle)) {
                        cameraAngle = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, angle * 0.5));
                    }
                    
                    // Также обновляем deviceOrientation для более точного трекинга
                    // Это помогает когда DeviceOrientation не доступен
                    if (!deviceOrientation.alpha || deviceOrientation.alpha === 0) {
                        // Используем акселерометр для приблизительной оценки ориентации
                        deviceOrientation.beta = 90 + Math.atan2(accel.y, accel.z) * 180 / Math.PI;
                        deviceOrientation.gamma = Math.atan2(accel.x, accel.z) * 180 / Math.PI;
                    }
                }
            }, false);
        }

        // Вычисление точки размещения модели в локальных координатах камеры
        function calculateLocalPlacementPoint(screenX, screenY) {
            // Преобразуем координаты экрана в нормализованные координаты (-1 до 1)
            const x = (screenX / window.innerWidth) * 2 - 1;
            const y = -(screenY / window.innerHeight) * 2 + 1;
            
            // Расстояние от камеры до точки размещения
            const distance = 1.5;
            
            // Вычисляем позицию в локальных координатах камеры
            const point = new THREE.Vector3();
            
            // Горизонтальная позиция (влево-вправо)
            point.x = x * 0.8;
            
            // Вертикальная позиция (вверх-вниз)
            const baseY = -0.3 - (y * 0.3);
            const angleAdjustment = Math.sin(cameraAngle) * distance * 0.2;
            point.y = baseY + angleAdjustment;
            
            // Глубина (расстояние от камеры)
            point.z = -distance + (y * 0.2);
            
            return point;
        }
        
        // Вычисление изменения ориентации камеры относительно начальной
        function getCameraRotationDelta() {
            if (!initialDeviceOrientation) return { x: 0, y: 0, z: 0 };
            
            let deltaAlpha = deviceOrientation.alpha - initialDeviceOrientation.alpha;
            // Нормализуем alpha в диапазон -180 до 180
            while (deltaAlpha > 180) deltaAlpha -= 360;
            while (deltaAlpha < -180) deltaAlpha += 360;
            
            const delta = {
                x: (deviceOrientation.beta - initialDeviceOrientation.beta) * Math.PI / 180,
                y: deltaAlpha * Math.PI / 180,
                z: (deviceOrientation.gamma - initialDeviceOrientation.gamma) * Math.PI / 180
            };
            
            // Ограничиваем значения для предотвращения резких скачков
            delta.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, delta.x));
            delta.y = Math.max(-Math.PI, Math.min(Math.PI, delta.y));
            delta.z = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, delta.z));
            
            return delta;
        }

        // Размещение модели в центре экрана
        function placeModelAtCenter() {
            if (!model || !markerRoot || modelPlaced) return;

            console.log('Размещение модели в центре');
            
            // Сохраняем начальную ориентацию устройства
            if (!initialDeviceOrientation) {
                initialDeviceOrientation = {
                    alpha: deviceOrientation.alpha,
                    beta: deviceOrientation.beta,
                    gamma: deviceOrientation.gamma
                };
            }
            
            // Вычисляем точку размещения в локальных координатах камеры
            worldModelPosition = calculateLocalPlacementPoint(
                window.innerWidth / 2, 
                window.innerHeight / 2
            );
            
            // Вычисляем нижнюю точку модели для корректного размещения на плоскости
            let modelHeightOffset = 0;
            if (model) {
                try {
                    const box = new THREE.Box3().setFromObject(model);
                    if (box.min.y !== Infinity && box.max.y !== Infinity) {
                        const modelHeight = box.max.y - box.min.y;
                        modelHeightOffset = (modelHeight * model.scale.y) / 2;
                    }
                } catch (e) {
                    modelHeightOffset = 0.1;
                }
            }
            
            // Сдвигаем позицию вниз на половину высоты модели
            worldModelPosition.y -= modelHeightOffset;
            
            // Удаляем модель из сцены если она там есть
            if (model.parent) {
                model.parent.remove(model);
            }
            
            // Устанавливаем начальную позицию
            markerRoot.position.copy(worldModelPosition);
            
            // Поворачиваем модель так, чтобы она стояла на плоскости
            markerRoot.rotation.x = -cameraAngle * 0.8;
            markerRoot.rotation.y = 0;
            markerRoot.rotation.z = 0;
            
            // Добавляем модель к markerRoot
            markerRoot.add(model);
            
            model.visible = true;
            modelPlaced = true;
            instructionsEl.style.display = 'none';
            statusEl.textContent = 'Модель закреплена в пространстве! Двигайте устройство - модель останется на месте.';
            
            console.log('Модель размещена в локальных координатах:', worldModelPosition);
        }
        
        // Обновление позиции модели для компенсации движения камеры
        function updateModelPositionFromWorld() {
            if (!worldModelPosition || !markerRoot || !initialDeviceOrientation) return;
            
            // Получаем изменение ориентации камеры
            const rotationDelta = getCameraRotationDelta();
            
            // Создаем копию начальной позиции модели в локальных координатах камеры
            const localPosition = worldModelPosition.clone();
            
            // Преобразуем изменение ориентации в кватернион для более точных расчетов
            const rotationQuaternion = new THREE.Quaternion();
            
            // Создаем кватернион из эйлеровых углов изменения
            // Используем обратные углы, чтобы компенсировать движение камеры
            const euler = new THREE.Euler(
                -rotationDelta.x * 0.7,  // Компенсируем наклон вперед/назад
                -rotationDelta.y,        // Компенсируем поворот влево/вправо
                -rotationDelta.z * 0.3   // Небольшая компенсация крена
            );
            
            rotationQuaternion.setFromEuler(euler);
            
            // Поворачиваем локальную позицию обратно, чтобы модель оставалась на месте
            localPosition.applyQuaternion(rotationQuaternion);
            
            // Применяем масштабирование компенсации в зависимости от наклона
            // При наклоне камеры вниз, расстояние до модели должно немного увеличиваться
            const distanceScale = 1 + Math.sin(rotationDelta.x) * 0.1;
            localPosition.multiplyScalar(distanceScale);
            
            // Обновляем позицию модели
            markerRoot.position.copy(localPosition);
        }

        // Обработка клика для размещения модели
        function onCanvasClick(event) {
            console.log('Клик зарегистрирован', model, markerRoot, modelPlaced);
            
            if (!model || !markerRoot) {
                console.log('Модель или markerRoot не готовы');
                return;
            }

            // Получаем координаты клика
            const rect = renderer.domElement.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            console.log('Координаты клика:', clickX, clickY);

            // Сохраняем начальную ориентацию устройства при первом размещении
            if (!initialDeviceOrientation) {
                initialDeviceOrientation = {
                    alpha: deviceOrientation.alpha,
                    beta: deviceOrientation.beta,
                    gamma: deviceOrientation.gamma
                };
            }
            
            // Вычисляем точку размещения в локальных координатах камеры
            worldModelPosition = calculateLocalPlacementPoint(clickX, clickY);
            
            // Вычисляем нижнюю точку модели для корректного размещения на плоскости
            let modelHeightOffset = 0;
            if (model) {
                try {
                    const box = new THREE.Box3().setFromObject(model);
                    if (box.min.y !== Infinity && box.max.y !== Infinity) {
                        const modelHeight = box.max.y - box.min.y;
                        modelHeightOffset = (modelHeight * model.scale.y) / 2;
                    }
                } catch (e) {
                    modelHeightOffset = 0.1;
                }
            }
            
            // Сдвигаем позицию вниз на половину высоты модели
            worldModelPosition.y -= modelHeightOffset;
            
            // Удаляем модель из текущего родителя если есть
            if (model.parent) {
                model.parent.remove(model);
            }
            
            // Устанавливаем позицию модели
            markerRoot.position.copy(worldModelPosition);
            
            // Поворачиваем модель так, чтобы она стояла на плоскости
            markerRoot.rotation.x = -cameraAngle * 0.8;
            markerRoot.rotation.y = 0;
            markerRoot.rotation.z = 0;
            
            // Добавляем модель к markerRoot
            markerRoot.add(model);
            
            model.visible = true;
            
            if (!modelPlaced) {
                modelPlaced = true;
                instructionsEl.style.display = 'none';
                statusEl.textContent = 'Модель закреплена в пространстве! Двигайте устройство - модель останется на месте.';
            } else {
                statusEl.textContent = 'Модель перемещена и закреплена в пространстве!';
            }
            
            console.log('Модель размещена в локальных координатах:', worldModelPosition);
        }

        // Анимационный цикл
        function animate() {
            requestAnimationFrame(animate);

            if (arToolkitSource && arToolkitSource.ready && arToolkitContext) {
                // Обновляем AR.js контекст
                arToolkitContext.update(arToolkitSource.domElement);
                
                // Обновляем матрицу проекции камеры
                camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
                
                // Для markerless режима устанавливаем камеру в начало координат
                camera.position.set(0, 0, 0);
                
                // Применяем небольшой наклон камеры для имитации реального угла обзора
                const cameraRotationX = cameraAngle * 0.3;
                camera.rotation.x = cameraRotationX;
                camera.rotation.y = 0;
                camera.rotation.z = 0;
                
                // Обновляем матрицу мира камеры
                camera.updateMatrixWorld(true);
                
                // Если модель размещена, обновляем её позицию относительно камеры
                // чтобы она оставалась закрепленной в мировых координатах
                if (model && model.visible && markerRoot && modelPlaced && worldModelPosition && initialDeviceOrientation) {
                    // Обновляем позицию модели из мировых координат с компенсацией движения
                    updateModelPositionFromWorld();
                    
                    // Обновляем ориентацию модели относительно плоскости
                    // Модель должна "стоять" на плоскости независимо от угла камеры
                    const rotationDelta = getCameraRotationDelta();
                    markerRoot.rotation.x = -cameraAngle * 0.8 - rotationDelta.x * 0.5;
                    // Небольшой поворот по Z для компенсации крена устройства
                    markerRoot.rotation.z = -rotationDelta.z * 0.3;
                }
            }

            // Обновляем анимации модели
            if (animationMixer) {
                const delta = clock.getDelta();
                animationMixer.update(delta);
            }

            // Рендеринг сцены
            renderer.render(scene, camera);
        }

        // Обработка изменения размера окна
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            if (arToolkitSource) {
                arToolkitSource.onResizeElement();
                arToolkitSource.onResize();
                if (arToolkitContext) {
                    arToolkitContext.update(arToolkitSource.domElement);
                }
            }
        }

        // Инициализация при загрузке страницы
        window.addEventListener('load', () => {
            init();
        });
    </script>
</body>
</html>



